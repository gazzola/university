<html dir="ltr"> <head>

<title>Projeto 1: Busca com Pacman</title>
<link href="projects.css" rel="stylesheet" type="text/css" />
</head> <body dir="ltr"> <h2>Projeto 1: Busca com Pacman</h2> <blockquote> <center> <img src="maze.png" width="400px" /> </center> 
<p><cite></cite><center><cite>All those colored walls,</cite><br />
<cite> Mazes give Pacman the blues,</cite><br />
<cite> So teach him to search.</cite></center><cite></cite></p> </blockquote> <h3>Introdução</h3> 
<p>Neste projeto, o seu agente Pacman irá encontrar caminhos no seu mundo em labirinto, tanto para alcançar um determinado local quanto para coletar alimentos de forma eficiente. Você construirá algoritmos gerais de busca e irá aplicá-los a cenários do Pacman. </p> 
<p>O código para este projeto consiste em vários arquivos Python, alguns dos quais você precisa ler e compreender a fim de completar a tarefa, e alguns que você pode ignorar.  <table border="0" cellpadding="10"> <tr><td colspan="2"><b>Arquivos que você irá editar:</b></td></tr>
 <tr><td><code><a href="docs/search.html">search.py</a></code></td> <td>Onde todos os seus algoritmos de busca deverão ficar.</td></tr>
 <tr><td><code><a href="docs/searchAgents.html">searchAgents.py</a></code></td> <td>Onde todos os seus agentes baseados em busca deverão ficar.</td></tr>
 <tr><td colspan="2"><b>Arquivos que você pode querer olhar:</b></td></tr>
 <tr><td><code><a href="docs/pacman.html">pacman.py</a></code></td> <td>O arquivo principal que executa os jogos do Pacman. Este arquivo descreve um tipo (classe) GameState (EstadoDoJogo) do Pacman, que você usará neste projeto.</td></tr>
 <tr><td><code><a href="docs/game.html">game.py</a></code></td> <td>A lógica por trás de como o mundo Pacman funciona. Este arquivo descreve vários tipos de apoio como AgentState, Agent, Direction, e Grid.</td></tr>
 <tr><td><code><a href="docs/util.html">util.py</a></code></td> <td>Estruturas de dados úteis para a implementação de algoritmos de busca.</td></tr>
 <tr><td colspan="2"><b>Arquivos de apoio que você pode ignorar:</b></td></tr>
 <tr><td><code><a href="docs/graphicsDisplay.html">graphicsDisplay.py</a></code></td> <td>Gráficos do Pacman</td></tr>
 <tr><td><code><a href="docs/graphicsUtils.html">graphicsUtils.py</a></code></td> <td>Suporte para os gráficos do Pacman</td></tr>
 <tr><td><code><a href="docs/textDisplay.html">textDisplay.py</a></code></td> <td>Gráficos ASCII para o Pacman</td></tr>
 <tr><td><code><a href="docs/ghostAgents.html">ghostAgents.py</a></code></td> <td>Agentes para controlar os fantasmas</td></tr>
 <tr><td><code><a href="docs/keyboardAgents.html">keyboardAgents.py</a></code></td> <td>Interfaces de teclado para controlar o Pacman</td></tr>
 <tr><td><code><a href="docs/layout.html">layout.py</a></code></td> <td>Código para ler arquivos de layout e armazenar seu conteúdo</td></tr>
 </table> 
<p> 
<p><strong>O que entregar:</strong> Você irá preencher partes em <code><a href="docs/search.html">search.py</a></code> ​​e em <code><a href="docs/searchAgents.html">searchAgents.py</a></code> durante esta tarefa. Você deverá enviar apenas esses dois arquivos com seu código e seus comentários, além de arquivos de suporte que vier a criar. Instruções para submissão estão no arquivo <a href="submission_instructions_pt_BR.html">submission_instructions_pt_BR.html</a>. </p> 
<p><strong>Avaliação:</strong> O seu código será avaliado automaticamente quanto à correção técnica. Por favor, <em>não altere</em> os nomes de quaisquer funções ou classes fornecidos no código, ou você vai atrapalhar a avaliação. No entanto, a corretude da sua implementação - e não a saída do avaliador automático - será o veredicto final de sua pontuação. Se necessário, iremos revisar e dar nota às tarefas individualmente para garantir que você receba o devido crédito por seu trabalho. 
<p><strong>Desonestidade Acadêmica:</strong> Verificaremos seu código contra outras submissões da turma e da internet quanto à redundância lógica. Se você copiar código de outra pessoa e apresentá-lo com pequenas alterações, iremos saber. Estes detectores de fraude são muito difíceis de enganar, então por favor, não tente. Confiamos que todos irão submeter apenas o seu próprio trabalho; <em>por favor,</em> não nos decepcione. Se fizer isso, iremos buscar as mais fortes consequências à nossa disposição. 
<p><strong>Obtendo Ajuda:</strong> Você não está sozinho! Se ficar preso em alguma coisa, entre em contato com a equipe do curso para obter ajuda. Horário de atendimento e o fórum de discussões estão lá para seu apoio; use-os.  Queremos que esses projetos sejam gratificantes e instrutivos, não frustrantes e desmoralizadores. Mas não sabemos quando ou como ajudar a menos que você peça. Mais um conselho: se você não sabe o que uma variável faz ou que tipo de valores ela leva, imprima-a na tela. <h3> Bem-vindo ao Pacman </h3> Depois de baixar o código (search.zip), descompactá-lo e mudar para o diretório <em>busca</em>, você deve ser capaz de jogar um jogo de Pacman digitando o seguinte na linha de comando: <pre>python pacman.py</pre> Pacman vive em um mundo azul brilhante de corredores sinuosos e saborosas guloseimas redondas. Navegar neste mundo de forma eficiente será o primeiro passo do Pacman para se tornar um mestre no seu domínio. 
<p> O agente mais simples em <a href="docs/searchAgents.html">searchAgents.py</a> é chamado de <code>GoWestAgent</code>, que sempre vai para o oeste (um agente reflexivo trivial). Este agente pode ocasionalmente ganhar: <pre>python pacman.py --layout testMaze --pacman GoWestAgent</pre> Mas as coisas ficam feias para este agente quando fazer uma curva é necessário: <pre>python pacman.py --layout tinyMaze --pacman GoWestAgent</pre> Se o pacman ficar preso você pode sair do jogo digitando CTRL-c em seu terminal. Em breve o seu agente irá resolver não só o minúsculo labirinto <code>tinyMaze</code>, mas qualquer labirinto que você desejar. Note-se que <code><a href="docs/pacman.html">pacman.py</a></code> suporta um número de opções que podem cada uma ser expressa de forma longa (por exemplo, <code>--layout</code>) ou de forma curta (por exemplo, <code>-l</code>). Você pode ver a lista de todas as opções e seus valores padrão através de: <pre>python pacman.py -h</pre> Além disso, todos os comandos que aparecem neste projeto também aparecem no arquivo <a href="commands.txt">commands.txt</a> para deixar fácil copiar e colar. No Linux/Mac OSX você pode até executar todos estes comandos em sequência usando <code>bash commands.txt</code>. 
<p> Nota: se você receber mensagens de erro sobre o Tkinter, veja <a href="http://tkinter.unpythonic.net/wiki/How_to_install_Tkinter">esta página</a>. <h3> Encontrando um ponto fixo de comida usando Algoritmos de Busca </h3> Em <code><a href="docs/searchAgents.html">searchAgents.py</a></code> você encontrará um Agente de Busca <code>SearchAgent</code>  totalmente implementado, que planeja um caminho através do mundo Pacman e, em seguida, executa o caminho passo a passo. Os algoritmos de busca para a formulação de um plano não estão implementados - esse é o seu trabalho. À medida que você for resolvendo as questões abaixo pode ser que precise consultar este <a href="search.html#Glossary">glossário de objetos no código</a> . Em primeiro lugar, teste se a <code>SearchAgent</code> está funcionando corretamente executando: <pre>python pacman.py -l tinyMaze -p SearchAgent -a fn=tinyMazeSearch</pre> O comando acima diz ao <code>SearchAgent</code> para usar o <code>tinyMazeSearch</code> como seu algoritmo de busca, que é implementado em <code><a href="docs/search.html">search.py</a></code>​​. O Pacman deve navegar pelo labirinto com sucesso. 
<p>Agora é hora de escrever funções de busca completas e genéricas para ajudar o Pacman a planejar rotas. Pseudocódigos para os algoritmos de busca que você irá escrever podem ser encontrados nos slides de aula e nos livros texto. Lembre-se que um nó de busca deve conter não apenas um estado mas também as informações necessárias para reconstruir o caminho (plano) que chega a esse estado. 
<p><em>Importante:</em> Todas as suas funções de busca precisam retornar uma lista de <em>ações</em> (<em>actions</em>) que levarão o agente do início para o objetivo. Estas ações têm de ser jogadas legais (direções válidas, não se movendo através de paredes). 
<p><em>Dica:</em> Cada algoritmo é muito semelhante. Algoritmos para DFS, BFS, UCS, e A* diferem apenas nos detalhes de como a franja (a lista de nós a expandir) é gerenciada. Então, se concentre em fazer direito a busca em profundidade (DFS) e o resto deve ser relativamente simples. De fato, uma das possíveis implementações requer apenas um único método de busca genérico que é configurado com uma estratégia de enfileiramento específica a um determinado algoritmo. (Sua implementação <em>não</em> precisa ser dessa forma para receber todo o crédito). 
<p><em>Dica:</em> Certifique-se de verificar os tipos <code>Stack</code> (pilha), <code>Queue</code> (fila) e <code>PriorityQueue</code> (fila de prioridade) fornecidos a você em <code><a href="docs/util.html">util.py</a></code>! </p> 
<p><em><strong>Questão 1 (2 pontos)</strong></em> Implemente o algoritmo de busca em profundidade (DFS) na função <code>depthFirstSearch</code> em <code><a href="docs/search.html">search.py</a></code>. Para fazer o seu algoritmo <em>completar</em>, escreva a versão da busca em grafo do DFS, que evita a expansão de quaisquer estados já visitados (seção 3.5 do livro). 
<p>O código deve encontrar rapidamente uma solução para: <pre>python pacman.py -l tinyMaze -p SearchAgent</pre> <pre>python pacman.py -l mediumMaze -p SearchAgent</pre> <pre>python pacman.py -l bigMaze -z .5 -p SearchAgent</pre> O tabuleiro do Pacman irá mostrar uma sobreposição dos estados explorados e da ordem em que foram exploradas (vermelho brilhante significa exploração mais cedo). A ordem de exploração é a que você esperaria? O Pacman realmente vai para todos os quadrados explorados em seu caminho para o objetivo? 
<p> <em>Dica:</em> Se você usar uma pilha (<code>Stack</code>) como sua estrutura de dados, a solução encontrada pelo seu algoritmo DFS para o labirinto médio (<code>mediumMaze</code>) deve ter um comprimento de 130 (desde que você empurre sucessores para a franja na ordem fornecida por getSuccessors; você pode ter 244 se empurrá-los na ordem inversa). Será esta uma solução de menor custo? Se não, pense sobre o que a busca em profundidade está fazendo errado. 
<p><em><strong>Questão 2 (1 ponto)</strong></em> Implemente o algoritmo da busca em largura (BFS) na função <code>breadthFirstSearch</code> em <code><a href="docs/search.html">search.py</a></code>. Mais uma vez, escreva um algoritmo de busca em grafo que evita a expansão de quaisquer estados já visitados. Teste seu código da mesma forma que você fez para a busca em profundidade. <pre>python pacman.py -l mediumMaze -p SearchAgent -a fn=bfs</pre> <pre>python pacman.py -l bigMaze -p SearchAgent -a fn=bfs -z .5</pre> A BFS encontra uma solução de menor custo? Se não, verifique a sua implementação. 
<p> <em>Dica:</em> Se o Pacman se mover muito lentamente, tente a opção <code>--frameTime 0</code>. 
<p> <em>Nota:</em> Caso você tenha escrito o seu código de pesquisa genericamente, ele deve funcionar igualmente bem para o problema de busca do quebra-cabeça &quot;oito&quot; (seção 3.2 do livro) sem quaisquer alterações. <pre>python eightpuzzle.py</pre> <h3> Variando a função de custo </h3> Enquanto a BFS vai encontrar um caminho com o menor número de ações para o objetivo, podemos querer encontrar caminhos que são &quot;melhores&quot; em outros sentidos. Considere <code><a href="layouts/mediumDottedMaze.lay">mediumDottedMaze</a></code> e <code><a href="layouts/mediumScaryMaze.lay">mediumScaryMaze</a></code>. Ao alterar a função de custo, podemos incentivar o Pacman a encontrar caminhos diferentes. Por exemplo, podemos cobrar mais por passos perigosos em áreas cheias de fantasmas ou menos por passos em áreas ricas em alimentos, e um agente de Pacman racional deve ajustar o seu comportamento em resposta. 
<p><em><strong>Questão 3 (2 pontos)</strong></em> Implemente o algoritmo de custo uniforme para busca em grafo na função <code>uniformCostSearch</code> em <code><a href="docs/search.html">search.py</a></code>. Encorajamos você a procurar em <code><a href="docs/util.html">util.py</a></code> por algumas estruturas de dados que podem ser úteis na sua implementação. Agora você deve observar um comportamento bem sucedido em todos os três layouts a seguir, onde os agentes abaixo são todos agentes UCS que diferem apenas na função de custo que usam (os agentes e as funções de custo estão escritos para você): <pre>python pacman.py -l mediumMaze -p SearchAgent -a fn=ucs</pre> <pre>python pacman.py -l mediumDottedMaze -p StayEastSearchAgent</pre> <pre>python pacman.py -l mediumScaryMaze -p StayWestSearchAgent</pre> 
<p> <em>Nota:</em> Você deve obter custos de caminho muito baixos e muito altos para o <code>StayEastSearchAgent</code> e <code>StayWestSearchAgent</code>, respectivamente, devido às suas funções de custo exponenciais (veja <code><a href="docs/searchAgents.html">searchAgents.py</a></code> para detalhes). <h3> Busca A* </h3> 
<p><em><strong>Questão 4 (3 pontos)</strong></em> Implemente a busca em grafo A* na função vazia <code>aStarSearch</code> em <code><a href="docs/search.html">search.py</a></code>. O A* usa uma função heurística como um argumento. Heurísticas recebem dois argumentos: um estado no problema de busca (o principal argumento), e o problema em si (para informações de referência). A função heurística <code>nullHeuristic</code> em <code><a href="docs/search.html">search.py</a></code> ​​é um exemplo trivial. 
<p>Você pode testar sua implementação A* no problema original de encontrar um caminho através de um labirinto para uma posição fixa usando a heurística de distância de Manhattan (já implementada como <code>manhattanHeuristic</code> em <code><a href="docs/searchAgents.html">searchAgents.py</a></code>). <pre>python pacman.py -l bigMaze -z .5 -p SearchAgent -a fn=astar,heuristic=manhattanHeuristic </pre> Você deve observar que o A* encontra a solução ideal ligeiramente mais rápido do que a busca de custo uniforme (cerca de 549 vs 620 nós de busca expandidos em nossa implementação, mas os desempates na fila de prioridade podem fazer seus números serem ligeiramente diferentes). O que acontece em <code>openMaze</code> para as várias estratégias de busca? <h3> Encontrando todos os cantos </h3> 
<p> O poder real do A* só será visível com um problema de busca mais desafiador. Agora, é hora de formular um novo problema e projetar uma heurística para ele. 
<p>Em <em>labirintos de canto</em> (<em>corner mazes</em>) existem quatro pontos, um em cada canto. Nosso novo problema de busca é encontrar o caminho mais curto através do labirinto que toca todos os quatro cantos (quer o labirinto realmente tenha comida lá ou não). Observe que, para alguns labirintos como <a href="layouts/tinyCorners.lay">tinyCorners</a>, o caminho mais curto nem sempre vai primeiro para o alimento mais próximo! <em>Dica:</em> o caminho mais curto através de <code>tinyCorners</code> leva 28 passos. 
<p><em><strong>Questão 5 (2 pontos)</strong></em> Implemente o problema de busca <code>CornersProblem</code> em <code><a href="docs/searchAgents.html">searchAgents.py</a></code>. Você terá que escolher uma representação dos estados que codifique todas as informações necessárias para detectar se todos os quatro cantos foram atingidos. Agora, o seu agente de busca deve resolver: <pre>python pacman.py -l tinyCorners -p SearchAgent -a fn=bfs,prob=CornersProblem</pre> <pre>python pacman.py -l mediumCorners -p SearchAgent -a fn=bfs,prob=CornersProblem</pre> Para receber o crédito integral, você precisa definir uma representação abstrata dos estados que <em>não</em> codifica informação irrelevante (como a posição de fantasmas, onde comida extra está, etc.). Em particular, não use um <code>GameState</code> do Pacman como um estado de busca. Seu código será muito, muito lento se você fizer isso (e também errado). 
<p> <em>Dica:</em> As únicas partes do estado do jogo que você precisa referenciar na sua implementação são a posição inicial do Pacman e a localização dos quatro cantos. 
<p>A nossa implementação de <code>breadthFirstSearch</code> expande um pouco menos de 2000 nós de busca em <a href="layouts/mediumCorners.lay">mediumCorners</a>. No entanto, heurísticas (usadas na busca A*) podem reduzir a quantidade de busca necessária. 
<p><em><strong>Questão 6 (3 pontos)</strong></em> Implemente uma heurística não-trivial e consistente para o <code>CornersProblem</code> em <code>cornersHeuristic</code>. Avaliação da nota: heurísticas inconsistentes não receberão <em>nenhum</em> crédito. 1 ponto para qualquer heurística não-trivial consistente. 1 ponto para a expansão de menos de 1.600 nós. 1 ponto para a expansão de menos de 1.200 nós. Expanda menos de 800 e você está indo muito bem! <pre>python pacman.py -l mediumCorners -p AStarCornersAgent -z 0.5</pre> 
<p> <em>Nota:</em> <code>AStarCornersAgent</code> é um atalho para <code>-p SearchAgent -a fn=aStarSearch,prob=CornersProblem,heuristic=cornersHeuristic</code>. 
<p> <em>Admissibilidade vs Consistência:</em> Lembre-se, heurísticas são apenas funções que recebem estados de busca e retornam números que estimam o custo para um objetivo mais próximo. Heurísticas mais eficazes retornarão valores mais próximos dos custos reais do objetivo. Para ser <em>admissível</em>, os valores da heurística devem ser limites inferiores do custo real do caminho mais curto para o próximo objetivo (e não negativos). Para ser <em>consistente</em>, a heurística deve, adicionalmente, garantir que se uma ação tem custo <em>c</em>, então tomar essa ação só pode causar uma queda na heurística de no máximo <em>c</em>. 
<p> Lembre-se que a admissibilidade não é suficiente para garantir a correção em buscas em grafos - é necessária a condição mais forte da consistência. No entanto, heurísticas admissíveis são geralmente também consistentes, especialmente se são derivadas de relaxações do problema. Por isso, é geralmente mais fácil começar inventando e criando heurísticas admissíveis. Uma vez que tiver uma heurística admissível que funciona bem, você pode verificar se ela é consistente também. A única maneira de garantir consistência é com uma prova. No entanto, a inconsistência pode geralmente ser detectada através da verificação de que, para cada nó que você expandir, nós sucessores são iguais ou maiores no valor de f. Além disso, se o UCS e o A* alguma vez retornarem caminhos de diferentes comprimentos, sua heurística é inconsistente. Essa coisa é complicada! Se você precisar de ajuda, não hesite em perguntar ao pessoal do curso. 
<p> <em>Heurísticas não-triviais:</em> As heurísticas triviais são aquelas que retornam zero sempre (UCS) e a heurística que calcula o custo verdadeiro de conclusão. O primeiro não vai lhe economizar nenhum tempo, enquanto o último irá estourar o tempo limite do avaliador automático. Você quer uma heurística que reduza o tempo de computação total, mas para esta tarefa o avaliador automático só irá verificar a contagem de nós (além de impor um limite de tempo razoável). 
<p> Além disso, qualquer heurística deve ser sempre não negativa, e deve retornar um valor de 0 em cada estado objetivo (tecnicamente este é um requisito da admissibilidade!). Vamos deduzir 1 ponto para qualquer heurística que retorna valores negativos, ou não se comporta adequadamente em estados objetivo.</p> <h3> Comendo todos os pontos </h3> Agora vamos resolver um problema difícil de busca: comer toda a comida do Pacman no menor número de passos possíveis. Para isso, precisamos de uma nova definição de problema de busca que formaliza o problema de limpar com a comida: <code>FoodSearchProblem</code> em <code><a href="docs/searchAgents.html">searchAgents.py</a></code> (implementado para você). Uma solução é definida como um caminho que coleta todo o alimento no mundo Pacman. Para este projeto, as soluções não levam em conta quaisquer fantasmas ou pastilhas de poder; as soluções dependem apenas da disposição das paredes, do alimento normal e do Pacman. (É claro que os fantasmas podem arruinar a execução de uma solução! Chegaremos nisso no próximo projeto.) Se você escreveu corretamente seus métodos gerais de busca, o <code>A*</code> com uma heurística nula (equivalente à busca de custo uniforme) deve encontrar rapidamente uma solução ótima para <a href="layouts/testSearch.lay">testSearch</a> sem qualquer alteração no código de sua parte (custo total de 7). <pre>python pacman.py -l testSearch -p AStarFoodSearchAgent</pre> 
<p> <em>Nota:</em> <code>AStarFoodSearchAgent</code> é um atalho para <code>-p SearchAgent -a fn=astar,prob=FoodSearchProblem,heuristic=foodHeuristic</code>. 
<p>Você irá perceber que a busca de custo uniforme começa a ficar lenta até mesmo para o aparentemente simples <code><a href="layouts/tinySearch.lay">tinySearch</a></code>. Como referência, nossa implementação leva 2,5 segundos para encontrar um caminho de comprimento 27 após uma expansão de 4902 nós de busca. 
<p> <em><strong>Questão 7 (5 pontos)</strong></em> Preencha <code>foodHeuristic</code> em <code><a href="docs/searchAgents.html">searchAgents.py</a></code> com uma heurística consistente para o <code>FoodSearchProblem</code>. Teste o seu agente no mapa <code>trickySearch</code>: <pre>python pacman.py -l trickySearch -p AStarFoodSearchAgent</pre> Nosso agente UCS encontra a solução ótima em aproximadamente 13 segundos, explorando mais de 16.000 nós. Qualquer heurística não-trivial consistente receberá 1 ponto. Você também receberá os seguintes pontos adicionais, dependendo de quão poucos nós a sua heurística expandir. <table align="center" border="1" cellspacing="1" cellpadding="5"> <tr><th>Menos nós que:</th><th>Pontos</th></tr>
 <tr><td>15000</td><td>1</td></tr>
 <tr><td>12000</td><td>2</td></tr>
 <tr><td>9000</td><td>3 (médio)</td></tr>
 <tr><td>7000</td><td>4 (difícil)</td></tr>
 </table> 
<p> <em>Lembre-se:</em> Se a sua heurística for inconsistente, você receberá <em>nenhum</em> crédito, por isso tome cuidado! Você consegue resolver <code><a href="layouts/mediumSearch.lay">mediumSearch</a></code> em pouco tempo? Se sim, então estamos ou muito, muito impressionados, ou a sua heurística é inconsistente. 
<p> Vamos deduzir 1 ponto para qualquer heurística que retorna valores negativos, ou não retorna 0 em cada estado objetivo.</p> <h3> Busca sub-ótima </h3> 
<p> Às vezes, mesmo com A* e uma boa heurística, encontrar o caminho ótimo através de todos os pontos é difícil. Nesses casos, ainda gostaríamos de encontrar um caminho razoavelmente bom, rapidamente. Nesta seção você irá escrever um agente que sempre gulosamente come o ponto mais próximo. <code>ClosestDotSearchAgent</code> está implementado para você em <code><a href="docs/searchAgents.html">searchAgents.py</a></code>, mas está faltando uma função fundamental que encontra um caminho para o ponto mais próximo. 
<p><em><strong>Questão 8 (2 pontos)</strong></em> Implemente a função <code>findPathToClosestDot</code> (encontra caminho para ponto mais próximo) em <code><a href="docs/searchAgents.html">searchAgents.py</a></code>. Nosso agente resolve esse labirinto (sub-otimamente!) em menos de um segundo com um custo de caminho de 350: <pre>python pacman.py -l bigSearch -p ClosestDotSearchAgent -z .5 </pre> 
<p> <em>Dica:</em> A forma mais rápida de completar <code>findPathToClosestDot</code> é preencher o problema <code>AnyFoodSearchProblem</code>, que está sem seu teste de objetivo. Depois, resolva esse problema com uma função de busca apropriada. A solução deve ser bem curta! 
<p>Seu agente <code>ClosestDotSearchAgent</code> nem sempre encontrará o caminho mais curto possível pelo labirinto.  Na verdade, você pode fazer melhor se tentar. 
<p><em><strong>Mini Concurso (até 2 pontos de crédito extra)</strong></em> Implemente um agente de busca aproximada (<code>ApproximateSearchAgent</code>) em <code><a href="docs/searchAgents.html">searchAgents.py</a></code> que encontra um caminho curto através do mapa <code>bigSearch</code>. Os 2 grupos que encontrarem o caminho mais curto usando não mais que 30 segundos de computação receberão 2 pontos extras e uma demonstração em aula de seus brilhantes agentes Pacman. Os grupos que ficarem em 3o e 4o receberão 1 ponto extra e os que ficaremem 5o e 6o receberão 0,5 pontos. <pre>python pacman.py -l bigSearch -p ApproximateSearchAgent -z .5 -q </pre> Marcaremos o tempo do seu agente sem usar gráficos (opção <code>-q</code>), e ele deve terminar em menos de 30 segundos nas nossas máquinas. Por favor descreva o que o seu agente está fazendo em um comentário! Reservamo-nos o direito de dar crédito extra adicional para soluções criativas, mesmo que não funcionem tão bem. Não codifique o caminho à mão, obviamente. <h3> <a name="Glossary">Glossário de objetos</a> </h3> 
<p> Aqui está um glossário dos principais objetos do código base referente a problemas de busca: <dl> <dt><code>SearchProblem (search.py)</code></dt> <dd>Um SearchProblem (problema de busca) é um objeto abstrato que representa o espaço de estados, a função sucessor, os custos e o estado objetivo de um problema. Você irá interagir com qualquer SearchProblem apenas através dos métodos definidos na parte superior do arquivo <code><a href="docs/search.html">search.py</a></code>.</dd> <dt><code>PositionSearchProblem (searchAgents.py)</code></dt> <dd>Um tipo específico de SearchProblem com o qual você trabalhará. Ele corresponde à busca de uma única pastilha em um labirinto. </dd> <dt><code>CornersProblem (searchAgents.py)</code></dt> <dd>Um tipo específico de SearchProblem que você irá definir. Ele corresponde à busca de um caminho através de todos os quatro cantos de um labirinto. </dd> <dt><code>FoodSearchProblem (searchAgents.py)</code></dt> <dd>Um tipo específico de SearchProblem com o qual você trabalhará. Ele corresponde a buscar uma maneira de comer todas as pastilhas em um labirinto. </dd> <dt>Função de Busca</dt> <dd>Uma função de busca é uma função que recebe uma instância de SearchProblem como parâmetro, executa algum algoritmo, e retorna uma seqüência de ações que levam a um objetivo. Exemplos de funções de busca são <code>depthFirstSearch</code> (busca em profundidade) e <code>breadthFirstSearch</code> (busca em largura), que você tem que escrever. Você tem à disposição a <code>tinyMazeSearch</code>, que é uma função de busca muito ruim que só funciona corretamente no labirinto <code>tinyMaze</code>. <dt><code>SearchAgent</code></dt> <dd><code>SearchAgent</code> é uma classe que implementa um Agente (um objeto que interage com o mundo) e faz seu planejamento através de uma função de busca. O <code>SearchAgent</code> primeiro usa a função de busca para fazer um plano de ações a serem tomadas para atingir o estado objetivo, e, em seguida, executa as ações uma por vez.</dd> </dd></dl> </p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></body> </html>
